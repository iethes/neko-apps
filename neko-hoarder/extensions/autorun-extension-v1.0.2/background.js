var background=function(){"use strict";function ce(e){return e==null||typeof e=="function"?{main:e}:e}const me=globalThis.browser?.runtime?.id?globalThis.browser:globalThis.chrome;function ee(e){return e&&e.__esModule&&Object.prototype.hasOwnProperty.call(e,"default")?e.default:e}var B={exports:{}},re;function de(){if(re)return B.exports;re=1;const e=r=>typeof crypto<"u"&&typeof crypto.getRandomValues=="function"?()=>{const g=crypto.getRandomValues(new Uint8Array(1))[0];return(g>=r?g%r:g).toString(r)}:()=>Math.floor(Math.random()*r).toString(r),n=(r=7,g=!1)=>Array.from({length:r},e(g?16:36)).join("");return B.exports=n,B.exports.default=n,B.exports}var ue=de();const L=ee(ue);var Ae=()=>`uid::${L(7)}`,fe=(e,n=["endpointName","fingerprint"])=>typeof e=="object"&&e!==null&&n.every(r=>r in e),pe=e=>{try{const n=JSON.parse(e);return fe(n)?n:null}catch{return null}},xe=()=>{let e=[];return{add:(...n)=>{e=[...e,...n]},remove:n=>{e=typeof n=="string"?e.filter(r=>r.message.transactionId!==n):e.filter(r=>!n.includes(r))},entries:()=>e}},R=class{static toBackground(e,n){return e.postMessage(n)}static toExtensionContext(e,n){return e.postMessage(n)}},be=Object.defineProperty,he=Object.defineProperties,ye=Object.getOwnPropertyDescriptors,ne=Object.getOwnPropertySymbols,we=Object.prototype.hasOwnProperty,ve=Object.prototype.propertyIsEnumerable,te=(e,n,r)=>n in e?be(e,n,{enumerable:!0,configurable:!0,writable:!0,value:r}):e[n]=r,T=(e,n)=>{for(var r in n||(n={}))we.call(n,r)&&te(e,r,n[r]);if(ne)for(var r of ne(n))ve.call(n,r)&&te(e,r,n[r]);return e},G=(e,n)=>he(e,ye(n)),Ee=/^((?:background$)|devtools|popup|options|content-script|window)(?:@(\d+)(?:\.(\d+))?)?$/,X=e=>{const[,n,r,g]=e.match(Ee)||[];return{context:n,tabId:+r,frameId:g?+g:void 0}},U=({context:e,tabId:n,frameId:r})=>["background","popup","options"].includes(e)?e:`${e}@${n}${r?`.${r}`:""}`;const _e=[{property:"name",enumerable:!1},{property:"message",enumerable:!1},{property:"stack",enumerable:!1},{property:"code",enumerable:!0}],H=Symbol(".toJSON was called"),ke=e=>{e[H]=!0;const n=e.toJSON();return delete e[H],n},se=({from:e,seen:n,to_:r,forceEnumerable:g,maxDepth:l,depth:o})=>{const t=r||(Array.isArray(e)?[]:{});if(n.push(e),o>=l)return t;if(typeof e.toJSON=="function"&&e[H]!==!0)return ke(e);for(const[s,m]of Object.entries(e)){if(typeof Buffer=="function"&&Buffer.isBuffer(m)){t[s]="[object Buffer]";continue}if(m!==null&&typeof m=="object"&&typeof m.pipe=="function"){t[s]="[object Stream]";continue}if(typeof m!="function"){if(!m||typeof m!="object"){t[s]=m;continue}if(!n.includes(e[s])){o++,t[s]=se({from:e[s],seen:[...n],forceEnumerable:g,maxDepth:l,depth:o});continue}t[s]="[Circular]"}}for(const{property:s,enumerable:m}of _e)typeof e[s]=="string"&&Object.defineProperty(t,s,{value:e[s],enumerable:!0,configurable:!0,writable:!0});return t};function Se(e,n={}){const{maxDepth:r=Number.POSITIVE_INFINITY}=n;return typeof e=="object"&&e!==null?se({from:e,seen:[],forceEnumerable:!0,maxDepth:r,depth:0}):typeof e=="function"?`[Function: ${e.name||"anonymous"}]`:e}let oe=()=>({events:{},emit(e,...n){(this.events[e]||[]).forEach(r=>r(...n))},on(e,n){return(this.events[e]=this.events[e]||[]).push(n),()=>this.events[e]=(this.events[e]||[]).filter(r=>r!==n)}});var Ce=(e,n,r)=>{const g=L(),l=new Map,o=new Map,t=s=>{if(s.destination.context===e&&!s.destination.frameId&&!s.destination.tabId){r?.(s);const{transactionId:m,messageID:x,messageType:A}=s,E=()=>{const h=l.get(m);if(h){const{err:f,data:S}=s;if(f){const w=f,Z=self[w.name],j=new(typeof Z=="function"?Z:Error)(w.message);for(const D in w)j[D]=w[D];h.reject(j)}else h.resolve(S);l.delete(m)}},I=async()=>{let h,f,S=!1;try{const w=o.get(x);if(typeof w=="function")h=await w({sender:s.origin,id:x,data:s.data,timestamp:s.timestamp});else throw S=!0,new Error(`[webext-bridge] No handler registered in '${e}' to accept messages with id '${x}'`)}catch(w){f=w}finally{if(f&&(s.err=Se(f)),t(G(T({},s),{messageType:"reply",data:h,origin:{context:e,tabId:null},destination:s.origin,hops:[]})),f&&!S)throw h}};switch(A){case"reply":return E();case"message":return I()}}return s.hops.push(`${e}::${g}`),n(s)};return{handleMessage:t,endTransaction:s=>{const m=l.get(s);m?.reject("Transaction was ended before it could complete"),l.delete(s)},sendMessage:(s,m,x="background")=>{const A=typeof x=="string"?X(x):x,E="Bridge#sendMessage ->";if(!A.context)throw new TypeError(`${E} Destination must be any one of known destinations`);return new Promise((I,h)=>{const f={messageID:s,data:m,destination:A,messageType:"message",transactionId:L(),origin:{context:e,tabId:null},hops:[],timestamp:Date.now()};l.set(f.transactionId,{resolve:I,reject:h});try{t(f)}catch(S){l.delete(f.transactionId),h(S)}})},onMessage:(s,m)=>(o.set(s,m),()=>o.delete(s))}},M=class{constructor(e,n){this.endpointRuntime=e,this.streamInfo=n,this.emitter=oe(),this.isClosed=!1,this.handleStreamClose=()=>{this.isClosed||(this.isClosed=!0,this.emitter.emit("closed",!0),this.emitter.events={})},M.initDone||(e.onMessage("__crx_bridge_stream_transfer__",r=>{const{streamId:g,streamTransfer:l,action:o}=r.data,t=M.openStreams.get(g);t&&!t.isClosed&&(o==="transfer"&&t.emitter.emit("message",l),o==="close"&&(M.openStreams.delete(g),t.handleStreamClose()))}),M.initDone=!0),M.openStreams.set(this.streamInfo.streamId,this)}get info(){return this.streamInfo}send(e){if(this.isClosed)throw new Error("Attempting to send a message over closed stream. Use stream.onClose(<callback>) to keep an eye on stream status");this.endpointRuntime.sendMessage("__crx_bridge_stream_transfer__",{streamId:this.streamInfo.streamId,streamTransfer:e,action:"transfer"},this.streamInfo.endpoint)}close(e){e&&this.send(e),this.handleStreamClose(),this.endpointRuntime.sendMessage("__crx_bridge_stream_transfer__",{streamId:this.streamInfo.streamId,streamTransfer:null,action:"close"},this.streamInfo.endpoint)}onMessage(e){return this.getDisposable("message",e)}onClose(e){return this.getDisposable("closed",e)}getDisposable(e,n){const r=this.emitter.on(e,n);return Object.assign(r,{dispose:r,close:r})}},W=M;W.initDone=!1,W.openStreams=new Map;var Te=e=>{const n=new Map,r=new Map,g=oe();e.onMessage("__crx_bridge_stream_open__",t=>new Promise(s=>{const{sender:m,data:x}=t,{channel:A}=x;let E=!1,I=()=>{};const h=()=>{const f=r.get(A);typeof f=="function"?(f(new W(e,G(T({},x),{endpoint:m}))),E&&I(),s(!0)):E||(E=!0,I=g.on("did-change-stream-callbacks",h))};h()}));async function l(t,s){if(n.has(t))throw new Error("webext-bridge: A Stream is already open at this channel");const m=typeof s=="string"?X(s):s,x={streamId:L(),channel:t,endpoint:m},A=new W(e,x);return A.onClose(()=>n.delete(t)),await e.sendMessage("__crx_bridge_stream_open__",x,m),n.set(t,A),A}function o(t,s){if(r.has(t))throw new Error("webext-bridge: This channel has already been claimed. Stream allows only one-on-one communication");r.set(t,s),g.emit("did-change-stream-callbacks")}return{openStream:l,onOpenStreamChannel:o}},q={exports:{}},Ie=q.exports,ie;function Pe(){return ie||(ie=1,function(e,n){(function(r,g){g(e)})(typeof globalThis<"u"?globalThis:typeof self<"u"?self:Ie,function(r){if(typeof globalThis!="object"||typeof chrome!="object"||!chrome||!chrome.runtime||!chrome.runtime.id)throw new Error("This script should only be loaded in a browser extension.");if(typeof globalThis.browser>"u"||Object.getPrototypeOf(globalThis.browser)!==Object.prototype){const g="The message port closed before a response was received.",l="Returning a Promise is the preferred way to send a reply from an onMessage/onMessageExternal listener, as the sendResponse will be removed from the specs (See https://developer.mozilla.org/docs/Mozilla/Add-ons/WebExtensions/API/runtime/onMessage)",o=t=>{const s={alarms:{clear:{minArgs:0,maxArgs:1},clearAll:{minArgs:0,maxArgs:0},get:{minArgs:0,maxArgs:1},getAll:{minArgs:0,maxArgs:0}},bookmarks:{create:{minArgs:1,maxArgs:1},get:{minArgs:1,maxArgs:1},getChildren:{minArgs:1,maxArgs:1},getRecent:{minArgs:1,maxArgs:1},getSubTree:{minArgs:1,maxArgs:1},getTree:{minArgs:0,maxArgs:0},move:{minArgs:2,maxArgs:2},remove:{minArgs:1,maxArgs:1},removeTree:{minArgs:1,maxArgs:1},search:{minArgs:1,maxArgs:1},update:{minArgs:2,maxArgs:2}},browserAction:{disable:{minArgs:0,maxArgs:1,fallbackToNoCallback:!0},enable:{minArgs:0,maxArgs:1,fallbackToNoCallback:!0},getBadgeBackgroundColor:{minArgs:1,maxArgs:1},getBadgeText:{minArgs:1,maxArgs:1},getPopup:{minArgs:1,maxArgs:1},getTitle:{minArgs:1,maxArgs:1},openPopup:{minArgs:0,maxArgs:0},setBadgeBackgroundColor:{minArgs:1,maxArgs:1,fallbackToNoCallback:!0},setBadgeText:{minArgs:1,maxArgs:1,fallbackToNoCallback:!0},setIcon:{minArgs:1,maxArgs:1},setPopup:{minArgs:1,maxArgs:1,fallbackToNoCallback:!0},setTitle:{minArgs:1,maxArgs:1,fallbackToNoCallback:!0}},browsingData:{remove:{minArgs:2,maxArgs:2},removeCache:{minArgs:1,maxArgs:1},removeCookies:{minArgs:1,maxArgs:1},removeDownloads:{minArgs:1,maxArgs:1},removeFormData:{minArgs:1,maxArgs:1},removeHistory:{minArgs:1,maxArgs:1},removeLocalStorage:{minArgs:1,maxArgs:1},removePasswords:{minArgs:1,maxArgs:1},removePluginData:{minArgs:1,maxArgs:1},settings:{minArgs:0,maxArgs:0}},commands:{getAll:{minArgs:0,maxArgs:0}},contextMenus:{remove:{minArgs:1,maxArgs:1},removeAll:{minArgs:0,maxArgs:0},update:{minArgs:2,maxArgs:2}},cookies:{get:{minArgs:1,maxArgs:1},getAll:{minArgs:1,maxArgs:1},getAllCookieStores:{minArgs:0,maxArgs:0},remove:{minArgs:1,maxArgs:1},set:{minArgs:1,maxArgs:1}},devtools:{inspectedWindow:{eval:{minArgs:1,maxArgs:2,singleCallbackArg:!1}},panels:{create:{minArgs:3,maxArgs:3,singleCallbackArg:!0},elements:{createSidebarPane:{minArgs:1,maxArgs:1}}}},downloads:{cancel:{minArgs:1,maxArgs:1},download:{minArgs:1,maxArgs:1},erase:{minArgs:1,maxArgs:1},getFileIcon:{minArgs:1,maxArgs:2},open:{minArgs:1,maxArgs:1,fallbackToNoCallback:!0},pause:{minArgs:1,maxArgs:1},removeFile:{minArgs:1,maxArgs:1},resume:{minArgs:1,maxArgs:1},search:{minArgs:1,maxArgs:1},show:{minArgs:1,maxArgs:1,fallbackToNoCallback:!0}},extension:{isAllowedFileSchemeAccess:{minArgs:0,maxArgs:0},isAllowedIncognitoAccess:{minArgs:0,maxArgs:0}},history:{addUrl:{minArgs:1,maxArgs:1},deleteAll:{minArgs:0,maxArgs:0},deleteRange:{minArgs:1,maxArgs:1},deleteUrl:{minArgs:1,maxArgs:1},getVisits:{minArgs:1,maxArgs:1},search:{minArgs:1,maxArgs:1}},i18n:{detectLanguage:{minArgs:1,maxArgs:1},getAcceptLanguages:{minArgs:0,maxArgs:0}},identity:{launchWebAuthFlow:{minArgs:1,maxArgs:1}},idle:{queryState:{minArgs:1,maxArgs:1}},management:{get:{minArgs:1,maxArgs:1},getAll:{minArgs:0,maxArgs:0},getSelf:{minArgs:0,maxArgs:0},setEnabled:{minArgs:2,maxArgs:2},uninstallSelf:{minArgs:0,maxArgs:1}},notifications:{clear:{minArgs:1,maxArgs:1},create:{minArgs:1,maxArgs:2},getAll:{minArgs:0,maxArgs:0},getPermissionLevel:{minArgs:0,maxArgs:0},update:{minArgs:2,maxArgs:2}},pageAction:{getPopup:{minArgs:1,maxArgs:1},getTitle:{minArgs:1,maxArgs:1},hide:{minArgs:1,maxArgs:1,fallbackToNoCallback:!0},setIcon:{minArgs:1,maxArgs:1},setPopup:{minArgs:1,maxArgs:1,fallbackToNoCallback:!0},setTitle:{minArgs:1,maxArgs:1,fallbackToNoCallback:!0},show:{minArgs:1,maxArgs:1,fallbackToNoCallback:!0}},permissions:{contains:{minArgs:1,maxArgs:1},getAll:{minArgs:0,maxArgs:0},remove:{minArgs:1,maxArgs:1},request:{minArgs:1,maxArgs:1}},runtime:{getBackgroundPage:{minArgs:0,maxArgs:0},getPlatformInfo:{minArgs:0,maxArgs:0},openOptionsPage:{minArgs:0,maxArgs:0},requestUpdateCheck:{minArgs:0,maxArgs:0},sendMessage:{minArgs:1,maxArgs:3},sendNativeMessage:{minArgs:2,maxArgs:2},setUninstallURL:{minArgs:1,maxArgs:1}},sessions:{getDevices:{minArgs:0,maxArgs:1},getRecentlyClosed:{minArgs:0,maxArgs:1},restore:{minArgs:0,maxArgs:1}},storage:{local:{clear:{minArgs:0,maxArgs:0},get:{minArgs:0,maxArgs:1},getBytesInUse:{minArgs:0,maxArgs:1},remove:{minArgs:1,maxArgs:1},set:{minArgs:1,maxArgs:1}},managed:{get:{minArgs:0,maxArgs:1},getBytesInUse:{minArgs:0,maxArgs:1}},sync:{clear:{minArgs:0,maxArgs:0},get:{minArgs:0,maxArgs:1},getBytesInUse:{minArgs:0,maxArgs:1},remove:{minArgs:1,maxArgs:1},set:{minArgs:1,maxArgs:1}}},tabs:{captureVisibleTab:{minArgs:0,maxArgs:2},create:{minArgs:1,maxArgs:1},detectLanguage:{minArgs:0,maxArgs:1},discard:{minArgs:0,maxArgs:1},duplicate:{minArgs:1,maxArgs:1},executeScript:{minArgs:1,maxArgs:2},get:{minArgs:1,maxArgs:1},getCurrent:{minArgs:0,maxArgs:0},getZoom:{minArgs:0,maxArgs:1},getZoomSettings:{minArgs:0,maxArgs:1},goBack:{minArgs:0,maxArgs:1},goForward:{minArgs:0,maxArgs:1},highlight:{minArgs:1,maxArgs:1},insertCSS:{minArgs:1,maxArgs:2},move:{minArgs:2,maxArgs:2},query:{minArgs:1,maxArgs:1},reload:{minArgs:0,maxArgs:2},remove:{minArgs:1,maxArgs:1},removeCSS:{minArgs:1,maxArgs:2},sendMessage:{minArgs:2,maxArgs:3},setZoom:{minArgs:1,maxArgs:2},setZoomSettings:{minArgs:1,maxArgs:2},update:{minArgs:1,maxArgs:2}},topSites:{get:{minArgs:0,maxArgs:0}},webNavigation:{getAllFrames:{minArgs:1,maxArgs:1},getFrame:{minArgs:1,maxArgs:1}},webRequest:{handlerBehaviorChanged:{minArgs:0,maxArgs:0}},windows:{create:{minArgs:0,maxArgs:1},get:{minArgs:1,maxArgs:2},getAll:{minArgs:0,maxArgs:1},getCurrent:{minArgs:0,maxArgs:1},getLastFocused:{minArgs:0,maxArgs:1},remove:{minArgs:1,maxArgs:1},update:{minArgs:2,maxArgs:2}}};if(Object.keys(s).length===0)throw new Error("api-metadata.json has not been included in browser-polyfill");class m extends WeakMap{constructor(a,d=void 0){super(d),this.createItem=a}get(a){return this.has(a)||this.set(a,this.createItem(a)),super.get(a)}}const x=i=>i&&typeof i=="object"&&typeof i.then=="function",A=(i,a)=>(...d)=>{t.runtime.lastError?i.reject(new Error(t.runtime.lastError.message)):a.singleCallbackArg||d.length<=1&&a.singleCallbackArg!==!1?i.resolve(d[0]):i.resolve(d)},E=i=>i==1?"argument":"arguments",I=(i,a)=>function(u,...b){if(b.length<a.minArgs)throw new Error(`Expected at least ${a.minArgs} ${E(a.minArgs)} for ${i}(), got ${b.length}`);if(b.length>a.maxArgs)throw new Error(`Expected at most ${a.maxArgs} ${E(a.maxArgs)} for ${i}(), got ${b.length}`);return new Promise((v,_)=>{if(a.fallbackToNoCallback)try{u[i](...b,A({resolve:v,reject:_},a))}catch(c){console.warn(`${i} API method doesn't seem to support the callback parameter, falling back to call it without a callback: `,c),u[i](...b),a.fallbackToNoCallback=!1,a.noCallback=!0,v()}else a.noCallback?(u[i](...b),v()):u[i](...b,A({resolve:v,reject:_},a))})},h=(i,a,d)=>new Proxy(a,{apply(u,b,v){return d.call(b,i,...v)}});let f=Function.call.bind(Object.prototype.hasOwnProperty);const S=(i,a={},d={})=>{let u=Object.create(null),b={has(_,c){return c in i||c in u},get(_,c,k){if(c in u)return u[c];if(!(c in i))return;let p=i[c];if(typeof p=="function")if(typeof a[c]=="function")p=h(i,i[c],a[c]);else if(f(d,c)){let O=I(c,d[c]);p=h(i,i[c],O)}else p=p.bind(i);else if(typeof p=="object"&&p!==null&&(f(a,c)||f(d,c)))p=S(p,a[c],d[c]);else if(f(d,"*"))p=S(p,a[c],d["*"]);else return Object.defineProperty(u,c,{configurable:!0,enumerable:!0,get(){return i[c]},set(O){i[c]=O}}),p;return u[c]=p,p},set(_,c,k,p){return c in u?u[c]=k:i[c]=k,!0},defineProperty(_,c,k){return Reflect.defineProperty(u,c,k)},deleteProperty(_,c){return Reflect.deleteProperty(u,c)}},v=Object.create(i);return new Proxy(v,b)},w=i=>({addListener(a,d,...u){a.addListener(i.get(d),...u)},hasListener(a,d){return a.hasListener(i.get(d))},removeListener(a,d){a.removeListener(i.get(d))}}),Z=new m(i=>typeof i!="function"?i:function(d){const u=S(d,{},{getContent:{minArgs:0,maxArgs:0}});i(u)});let j=!1;const D=new m(i=>typeof i!="function"?i:function(d,u,b){let v=!1,_,c=new Promise(F=>{_=function(C){j||(console.warn(l,new Error().stack),j=!0),v=!0,F(C)}}),k;try{k=i(d,u,_)}catch(F){k=Promise.reject(F)}const p=k!==!0&&x(k);if(k!==!0&&!p&&!v)return!1;const O=F=>{F.then(C=>{b(C)},C=>{let Q;C&&(C instanceof Error||typeof C.message=="string")?Q=C.message:Q="An unexpected error occurred",b({__mozWebExtensionPolyfillReject__:!0,message:Q})}).catch(C=>{console.error("Failed to send onMessage rejected reply",C)})};return O(p?k:c),!0}),We=({reject:i,resolve:a},d)=>{t.runtime.lastError?t.runtime.lastError.message===g?a():i(new Error(t.runtime.lastError.message)):d&&d.__mozWebExtensionPolyfillReject__?i(new Error(d.message)):a(d)},le=(i,a,d,...u)=>{if(u.length<a.minArgs)throw new Error(`Expected at least ${a.minArgs} ${E(a.minArgs)} for ${i}(), got ${u.length}`);if(u.length>a.maxArgs)throw new Error(`Expected at most ${a.maxArgs} ${E(a.maxArgs)} for ${i}(), got ${u.length}`);return new Promise((b,v)=>{const _=We.bind(null,{resolve:b,reject:v});u.push(_),d.sendMessage(...u)})},qe={devtools:{network:{onRequestFinished:w(Z)}},runtime:{onMessage:w(D),onMessageExternal:w(D),sendMessage:le.bind(null,"sendMessage",{minArgs:1,maxArgs:3})},tabs:{sendMessage:le.bind(null,"sendMessage",{minArgs:2,maxArgs:3})}},Y={clear:{minArgs:1,maxArgs:1},get:{minArgs:1,maxArgs:1},set:{minArgs:1,maxArgs:1}};return s.privacy={network:{"*":Y},services:{"*":Y},websites:{"*":Y}},S(t,qe,s)};r.exports=o(chrome)}else r.exports=globalThis.browser})}(q)),q.exports}var Me=Pe();const Ne=ee(Me);var $=xe(),y=new Map,N=new Map,z=new Map,ae=(e,n)=>(N.set(e,(N.get(e)||new Set).add(n)),()=>{const r=N.get(e);r?.delete(n)&&r?.size===0&&N.delete(e)}),ge=(e,n)=>{z.set(e,(z.get(e)||new Set).add(n))},P=e=>({withFingerprint:n=>{const r=l=>({and:()=>l}),g={aboutIncomingMessage:l=>{const o=y.get(e);return R.toExtensionContext(o.port,{status:"incoming",message:l}),r(g)},aboutSuccessfulDelivery:l=>{const o=y.get(e);return R.toExtensionContext(o.port,{status:"delivered",receipt:l}),r(g)},aboutMessageUndeliverability:(l,o)=>{const t=y.get(e);return t?.fingerprint===n&&R.toExtensionContext(t.port,{status:"undeliverable",resolvedDestination:l,message:o}),r(g)},whenDeliverableTo:l=>{const o=()=>{const t=y.get(e);if(t?.fingerprint===n&&y.has(l))return R.toExtensionContext(t.port,{status:"deliverable",deliverableTo:l}),!0};if(!o()){const t=ae(l,o);ge(n,t)}return r(g)},aboutSessionEnded:l=>{const o=y.get(e);return o?.fingerprint===n&&R.toExtensionContext(o.port,{status:"terminated",fingerprint:l}),r(g)}};return g}}),Oe=Ae(),V=Ce("background",e=>{var n;if(e.origin.context==="background"&&["content-script","devtools "].includes(e.destination.context)&&!e.destination.tabId)throw new TypeError("When sending messages from background page, use @tabId syntax to target specific tab");const r=U(T(T({},e.origin),e.origin.context==="window"&&{context:"content-script"})),g=U(G(T(T({},e.destination),e.destination.context==="window"&&{context:"content-script"}),{tabId:e.destination.tabId||e.origin.tabId}));e.destination.tabId=null,e.destination.frameId=null;const l=()=>y.get(g),o=()=>y.get(r),t=()=>{var s;P(g).withFingerprint(l().fingerprint).aboutIncomingMessage(e);const m={message:e,to:l().fingerprint,from:{endpointId:r,fingerprint:(s=o())==null?void 0:s.fingerprint}};e.messageType==="message"&&$.add(m),e.messageType==="reply"&&$.remove(e.messageID),o()&&P(r).withFingerprint(o().fingerprint).aboutSuccessfulDelivery(m)};(n=l())!=null&&n.port?t():e.messageType==="message"&&(e.origin.context==="background"?ae(g,t):o()&&P(r).withFingerprint(o().fingerprint).aboutMessageUndeliverability(g,e).and().whenDeliverableTo(g))},e=>{const n=U(T(T({},e.origin),e.origin.context==="window"&&{context:"content-script"})),r=y.get(n),g={message:e,to:Oe,from:{endpointId:n,fingerprint:r.fingerprint}};P(n).withFingerprint(r.fingerprint).aboutSuccessfulDelivery(g)});Ne.runtime.onConnect.addListener(e=>{var n;const r=pe(e.name);if(!r)return;r.endpointName||(r.endpointName=U({context:"content-script",tabId:e.sender.tab.id,frameId:e.sender.frameId}));const{tabId:g,frameId:l}=X(r.endpointName);y.set(r.endpointName,{fingerprint:r.fingerprint,port:e}),(n=N.get(r.endpointName))==null||n.forEach(o=>o()),N.delete(r.endpointName),ge(r.fingerprint,()=>{const o=$.entries().filter(t=>t.to===r.fingerprint);$.remove(o),o.forEach(t=>{t.from.endpointId==="background"?V.endTransaction(t.message.transactionId):P(t.from.endpointId).withFingerprint(t.from.fingerprint).aboutSessionEnded(r.fingerprint)})}),e.onDisconnect.addListener(()=>{var o,t;((o=y.get(r.endpointName))==null?void 0:o.fingerprint)===r.fingerprint&&y.delete(r.endpointName),(t=z.get(r.fingerprint))==null||t.forEach(s=>s()),z.delete(r.fingerprint)}),e.onMessage.addListener(o=>{var t,s;if(o.type==="sync"){const m=[...y.values()].map(A=>A.fingerprint),x=o.pendingResponses.filter(A=>m.includes(A.to));$.add(...x),o.pendingResponses.filter(A=>!m.includes(A.to)).forEach(A=>P(r.endpointName).withFingerprint(r.fingerprint).aboutSessionEnded(A.to)),o.pendingDeliveries.forEach(A=>P(r.endpointName).withFingerprint(r.fingerprint).whenDeliverableTo(A));return}o.type==="deliver"&&((s=(t=o.message)==null?void 0:t.origin)!=null&&s.context)&&(o.message.origin.tabId=g,o.message.origin.frameId=l,V.handleMessage(o.message))})});var{sendMessage:Re,onMessage:$e}=V;Te(V);const je="https://hoarder-backend-api-889965658265.asia-southeast1.run.app",De="autohoarder-1.0.1",Fe="nC7ZtAMzaXiLfWsIkhav1oGwtKXXN+Sy0434Tmv/XsE=";async function Be(e){try{const n=je+`/intercepted-response?api_key=${encodeURIComponent(Fe)}`,r=await fetch(n,{method:"POST",cache:"no-cache",headers:{"Content-Type":"application/json"},body:JSON.stringify({...e.payload,key:De})});return{ok:r.ok,status:r.status}}catch(n){return console.error("Webhook error:",n),{ok:!1,status:500,error:n instanceof Error?n.message:String(n)}}}const Le=ce(()=>{$e("webhook",async({data:e})=>await Be(e)),me.tabs.onUpdated.addListener(async(e,n,r)=>{n.url&&n.url.includes("/verify/captcha")&&(console.log("Captcha detected on tab:",e),await Re("solveCaptcha",{},{context:"content-script",tabId:e}))})});function Ve(){}function J(e,...n){}const Ue={debug:(...e)=>J(console.debug,...e),log:(...e)=>J(console.log,...e),warn:(...e)=>J(console.warn,...e),error:(...e)=>J(console.error,...e)};let K;try{K=Le.main(),K instanceof Promise&&console.warn("The background's main() function return a promise, but it must be synchronous")}catch(e){throw Ue.error("The background crashed on startup!"),e}return K}();
background;
